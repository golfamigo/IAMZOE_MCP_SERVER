基於「Gemini完善的資料模型.md」和「Gemini的API規範文件.md」開發一個MCP Server。
使用TypeScript編寫。
在當前目錄（e:/gitHub/IAMZOE MCP SERVER）下直接開始編寫程式碼。
使用Neo4j資料庫（已提供連接信息）。
實現API規範文件中列出的所有API端點。
使用API金鑰進行身份驗證。
不需要額外的自定義錯誤碼。
不需要額外的安全措施（如頻率限制、IP過濾）。
開發計劃：

初始化項目：
創建 package.json 文件，使用 npm init -y。
安裝必要的依賴：@modelcontextprotocol/sdk, express, neo4j-driver, ajv, dotenv, typescript, @types/express, @types/node.
創建 tsconfig.json 文件，配置TypeScript編譯選項。
建立 .env 檔並加入環境變數 NEO4J_URI, NEO4J_USERNAME, NEO4J_PASSWORD, API_KEY (API_KEY 的值需要詢問使用者)
建立基本架構：
創建 src 目錄。
在 src 目錄下創建 index.ts 作為入口文件。
在 index.ts 中：
導入必要的模塊。
初始化 Express 應用程序。
創建 MCP Server 實例。
連接到 Neo4j 資料庫。
設置基本的錯誤處理。
啟動 MCP Server。
實現API端點：
根據API規範文件，逐個實現API端點。
對於每個端點：
定義路由。
編寫處理函數。
驗證請求參數和請求體（使用Ajv）。
執行業務邏輯（與Neo4j資料庫交互）。
返回響應。
處理錯誤。
將API端點按照功能模塊（預約、顧客、員工、服務、類別、會員等級、廣告、用戶關係）組織到不同的文件中。
實現資料庫交互：
創建一個單獨的模塊（例如 db.ts）來處理與Neo4j資料庫的交互。
根據資料模型文件，編寫Cypher查詢。
使用 neo4j-driver 執行Cypher查詢。
處理資料庫錯誤。
實現身份驗證：
創建一個中間件來驗證API金鑰。
在所有需要身份驗證的API端點上使用此中間件。
編寫測試：
為每個API端點編寫單元測試和集成測試。
使用測試框架（例如Jest）來運行測試。
部署：
提供部署說明，指導用戶如何部署MCP Server。
專案結構:

e:/gitHub/IAMZOE MCP SERVER/
├── .env                     # 環境變數
├── package.json             # 專案設定檔
├── tsconfig.json            # TypeScript 設定檔
└── src/                     # 原始碼目錄
    ├── index.ts             # 入口檔案
    ├── db.ts                # 資料庫互動模組
    ├── middleware/          # 中間件
    │   └── auth.ts          # 身份驗證中間件
    ├── routes/              # API 路由
    │   ├── bookings.ts      # 預約相關 API
    │   ├── customers.ts     # 顧客相關 API
    │   ├── staff.ts         # 員工相關 API
    │   ├── services.ts      # 服務相關 API
    │   ├── categories.ts    # 類別相關 API
    │   ├── membershipLevels.ts # 會員等級相關 API
        ├── advertisements.ts # 廣告相關 API
        └── userRelationships.ts # 使用者關係相關 API
    └── types/               # TypeScript 類型定義
        └── api.ts           # API 請求和回應的類型定義

下一步行動

我將向用戶確認此開發計劃，並詢問API金鑰的值。

這是我為您制定的 MCP Server 開發計劃：

專案結構:

e:/gitHub/IAMZOE MCP SERVER/
├── .env                     # 環境變數
├── package.json             # 專案設定檔
├── tsconfig.json            # TypeScript 設定檔
└── src/                     # 原始碼目錄
    ├── index.ts             # 入口檔案
    ├── db.ts                # 資料庫互動模組
    ├── middleware/          # 中間件
    │   └── auth.ts          # 身份驗證中間件
    ├── routes/              # API 路由
    │   ├── bookings.ts      # 預約相關 API
    │   ├── customers.ts     # 顧客相關 API
    │   ├── staff.ts         # 員工相關 API
    │   ├── services.ts      # 服務相關 API
    │   ├── categories.ts    # 類別相關 API
    │   ├── membershipLevels.ts # 會員等級相關 API
        ├── advertisements.ts # 廣告相關 API
        └── userRelationships.ts # 使用者關係相關 API
    └── types/               # TypeScript 類型定義
        └── api.ts           # API 請求和回應的類型定義

開發步驟：

初始化專案：

使用 npm init -y 建立 package.json 檔案。
安裝必要的依賴：@modelcontextprotocol/sdk, express, neo4j-driver, ajv, dotenv, typescript, @types/express, @types/node。
建立 tsconfig.json 檔案，配置 TypeScript 編譯選項。
建立 .env 檔案，並加入環境變數：NEO4J_URI、NEO4J_USERNAME、NEO4J_PASSWORD、API_KEY (稍後會請您提供 API_KEY 的值)。
建立基本架構：

建立 src 目錄。
在 src 目錄下建立 index.ts 作為入口檔案。
在 index.ts 中：
導入必要的模組。
初始化 Express 應用程式。
建立 MCP Server 實例。
連接到 Neo4j 資料庫。
設置基本的錯誤處理。
啟動 MCP Server。
實現 API 端點：

根據 API 規範文件，逐個實現 API 端點。
對於每個端點：
定義路由。
編寫處理函數。
驗證請求參數和請求體 (使用 Ajv)。
執行業務邏輯 (與 Neo4j 資料庫交互)。
返回響應。
處理錯誤。
將 API 端點按照功能模組 (預約、顧客、員工、服務、類別、會員等級) 組織到 routes 目錄下的不同檔案中。
實現資料庫交互：

建立一個單獨的模組 (db.ts) 來處理與 Neo4j 資料庫的交互。
根據資料模型文件，編寫 Cypher 查詢。
使用 neo4j-driver 執行 Cypher 查詢。
處理資料庫錯誤。
實現身份驗證：

建立一個中間件 (middleware/auth.ts) 來驗證 API 金鑰。
在所有需要身份驗證的 API 端點上使用此中間件。
編寫測試：

為每個 API 端點編寫單元測試和整合測試。
使用測試框架 (例如 Jest) 來運行測試。
部署：

提供部署說明，指導您如何部署 MCP Server。